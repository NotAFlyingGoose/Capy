
HYPHEN :: 45;
PERIOD :: 46;
ZERO :: 48;

reverse :: (buf: ^mut [20]u8, starting_offset: usize, len: usize) {
    i := starting_offset;
    j := len - 1;
    temp := 0;

    while i < j {
        temp = buf^[i];
        buf^[i] = buf^[j];
        buf^[j] = temp;
        i = i + 1;
        j = j - 1;
    }
}

int_to_string :: (n: i32, buf: ^mut [20]u8, buf_offset: usize, required_digits: usize) -> usize {
    idx := buf_offset;

    n := n;
    if n < 0 {
        n = -n;
        buf^[idx] = HYPHEN; // 45 is the unicode hyphen
        idx = idx + 1;
    }

    if n == 0 {
        buf^[idx] = ZERO;
        idx = idx + 1;
    }

    while n != 0 {
        remainder := n % 10;
        n = n / 10;

        buf^[idx] = {ZERO + remainder} as u8;

        idx = idx + 1;
    }

    while idx < required_digits {
        buf^[idx] = ZERO;
        idx = idx + 1;
    }

    reverse(buf, buf_offset, idx);

    idx
}

ftoa :: (n: f32, buf: ^mut [20]u8, afterpoint: usize) {
    ipart := n as i32;

    fpart := n - {ipart as f32};

    idx := int_to_string(ipart, buf, 0, 0);

    if afterpoint != 0 {
        buf^[idx] = PERIOD;

        fpart = fpart * pow(10, afterpoint as i32) as f32;

        // add one for the period
        int_to_string(fpart as i32, buf, idx + 1, afterpoint);
    }
}

pow :: (base: i32, exp: i32) -> i32 {
    result := 1;

    i := 0;
    while i < exp {
        result = result * base;
        i = i + 1;
    }

    result
}

main :: () {
    // it'd be easier to do a malloc and free here, but there is currently no pointer math
    buf := [20]u8 { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

    ftoa(12.5, ^mut buf, 3);

    puts(buf);
}

puts :: (str: [20]u8) extern;