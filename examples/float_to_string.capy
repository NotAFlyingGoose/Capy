libc :: import "std/libc.capy";
math :: import "std/math.capy";

HYPHEN : u8 : 45;
PERIOD : u8 : 46;
ZERO : u8 : 48;

reverse :: (buf: ^mut [20]u8, starting_offset: usize, len: usize) {
    i := starting_offset;
    j := len - 1;
    temp := 0;

    while i < j {
        temp = buf^[i];
        buf^[i] = buf^[j];
        buf^[j] = temp;
        i = i + 1;
        j = j - 1;
    }
}

int_to_string :: (n: i32, buf: ^mut [20]u8, buf_offset: usize, required_digits: usize) -> usize {
    idx := buf_offset;

    n := n;
    if n < 0 {
        n = -n;
        buf^[idx] = HYPHEN; // 45 is the unicode hyphen
        idx = idx + 1;
    }

    if n == 0 {
        buf^[idx] = ZERO;
        idx = idx + 1;
    }

    while n != 0 {
        remainder := n % 10;
        n = n / 10;

        buf^[idx] = {ZERO + remainder} as u8;

        idx = idx + 1;
    }

    while idx - buf_offset < required_digits {
        buf^[idx] = ZERO;
        idx = idx + 1;
    }

    reverse(buf, buf_offset, idx);

    idx
}

ftoa :: (n: f32, buf: ^mut [20]u8, afterpoint: usize) {
    clear_buf(buf);

    ipart := n as i32;

    fpart := n - {ipart as f32};

    idx := int_to_string(ipart, buf, 0, 0);

    if afterpoint != 0 {
        buf^[idx] = PERIOD;

        fpart = fpart * math.pow(10, afterpoint as i32) as f32;

        // add one for the period
        int_to_string(fpart as i32, buf, idx + 1, afterpoint);
    }
}

clear_buf :: (buf: ^mut [20]u8) {
    idx := 0;
    while idx < 20 {
        buf^[idx] = 0;
        idx = idx + 1;
    }
}

main :: () {
    // libc.malloc returns a `^mut any`, so we must explicitly cast that to the pointer type we want
    buf := libc.malloc(20) as ^mut [20]u8;

    ftoa(3.14159, buf, 3);
    print_buf(buf);
    printf("\n");

    printf("ln 10 = ");
    ftoa(comptime { math.ln(10) as f32 }, buf, 3);
    print_buf(buf);

    printf("ln 50 = ");
    ftoa(comptime { math.ln(50) as f32 }, buf, 3);
    print_buf(buf);

    printf("ln 100 = ");
    ftoa(comptime { math.ln(100) as f32 }, buf, 3);
    print_buf(buf);

    printf("ln 500 = ");
    ftoa(comptime { math.ln(500) as f32 }, buf, 3);
    print_buf(buf);

    printf("log 10 = ");
    ftoa(comptime { math.log10(10) as f32 }, buf, 3);
    print_buf(buf);

    printf("log 50 = ");
    ftoa(comptime { math.log10(50) as f32 }, buf, 3);
    print_buf(buf);

    printf("log 100 = ");
    ftoa(comptime { math.log10(100) as f32 }, buf, 3);
    print_buf(buf);

    printf("log 500 = ");
    ftoa(comptime { math.log10(500) as f32 }, buf, 3);
    print_buf(buf);

    libc.free(buf);
}

print_buf :: (buf: ^[20]u8) {
    ptr := buf as ^any;
    ptr := ptr as string;
    libc.puts(ptr);
}

// this is only to avoid the newline in `libc.puts`
printf :: (str: string) extern;