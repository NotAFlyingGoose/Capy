
global :: [][3][3] i8 {
        [][3] i8 { [] i8 { 105, 115, 125 }, [] i8 { 105, 115, 127 }, [] i8 { 105, 115, 125 } },
        [][3] i8 { [] i8 { 105, 115, 125 }, [] i8 { 105, 115, 125 }, [] i8 { 105, 115, 125 } },
        [][3] i8 { [] i8 { 105, 115, 125 }, [] i8 { 105, 115, 125 }, [] i8 { 105, 115, 125 } }
    };

make_array :: (x: i8, y: i8, z: i8) -> [3][3][3] i8 {
    [][3][3] i8 {
        [][3] i8 { [] i8 { x, y, z }, [] i8 { x, y, z }, [] i8 { x, y, z } },
        [][3] i8 { [] i8 { x, y, z }, [] i8 { x, y, z }, [] i8 { x, y, z } },
        [][3] i8 { [] i8 { x, y, z }, [] i8 { x, y, z }, [] i8 { x, y, z } }
    }
}

// prints out an array on the stack, and one in global memory
main :: () -> usize {
    my_array := make_array(2, 4, 6);

    // the stack memory of the above array isn't cleared, even if the old stack is overwritten by new function calls
    make_array(8, 10, 12);

    edit(^mut my_array);
    
    print_array_by_value(my_array, "my_array");

    puts("");

    print_array_by_ref(^global, "global");

    0
}

edit :: (arr: ^mut [3][3][3]i8) {
    arr^[1][1] = [3]i8{ 127, 0, 42 };
}

// since the array is passed by value, it is memcpy'd into the stack of this function
print_array_by_value :: (arr: [3][3][3]i8, name: string) {
    x : usize = 0;
    while x < 3 {
        y : usize = 0;
        while y < 3 {
            z : usize = 0;
            while z < 3 {
                printf("%s[%i][%i][%i] = %i\n", name, x as i32, y as i32, z as i32, arr[x][y][z] as i32);
                z = z + 1;
            }
            y = y + 1;
        }
        x = x + 1;
    }
}

// While [] is internally a pointer, ^[] doesn't mean a pointer to a pointer. It means pass-by-reference.
// In other words, the only difference between this function and the one above is the lack of a memcpy.
print_array_by_ref :: (arr: ^[3][3][3]i8, name: string) {
    x : usize = 0;
    while x < 3 {
        y : usize = 0;
        while y < 3 {
            z : usize = 0;
            while z < 3 {
                printf("%s[%i][%i][%i] = %i\n", name, x as i32, y as i32, z as i32, arr^[x][y][z]);
                z = z + 1;
            }
            y = y + 1;
        }
        x = x + 1;
    }
}

printf :: (s: string, name: string, n1: i32, n2: i32, n3: i32, n4: i32) extern;
puts :: (s: string) extern;